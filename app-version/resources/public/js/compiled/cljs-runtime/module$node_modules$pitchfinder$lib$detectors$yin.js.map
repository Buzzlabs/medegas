{
"version":3,
"file":"module$node_modules$pitchfinder$lib$detectors$yin.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/pitchfinder/lib/detectors/yin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pitchfinder$lib$detectors$yin\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_YIN_PARAMS = {\n    threshold: 0.1,\n    sampleRate: 44100,\n    probabilityThreshold: 0.1,\n};\nfunction YIN(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_YIN_PARAMS), params);\n    var threshold = config.threshold, sampleRate = config.sampleRate, probabilityThreshold = config.probabilityThreshold;\n    return function YINDetector(float32AudioBuffer) {\n        // Set buffer size to the highest power of two below the provided buffer's length.\n        var bufferSize;\n        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2)\n            ;\n        bufferSize /= 2;\n        // Set up the yinBuffer as described in step one of the YIN paper.\n        var yinBufferLength = bufferSize / 2;\n        var yinBuffer = new Float32Array(yinBufferLength);\n        var probability = 0, tau;\n        // Compute the difference function as described in step 2 of the YIN paper.\n        for (var t = 0; t < yinBufferLength; t++) {\n            yinBuffer[t] = 0;\n        }\n        for (var t = 1; t < yinBufferLength; t++) {\n            for (var i = 0; i < yinBufferLength; i++) {\n                var delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];\n                yinBuffer[t] += delta * delta;\n            }\n        }\n        // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n        yinBuffer[0] = 1;\n        yinBuffer[1] = 1;\n        var runningSum = 0;\n        for (var t = 1; t < yinBufferLength; t++) {\n            runningSum += yinBuffer[t];\n            yinBuffer[t] *= t / runningSum;\n        }\n        // Compute the absolute threshold as described in step 4 of the paper.\n        // Since the first two positions in the array are 1,\n        // we can start at the third position.\n        for (tau = 2; tau < yinBufferLength; tau++) {\n            if (yinBuffer[tau] < threshold) {\n                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n                    tau++;\n                }\n                // found tau, exit loop and return\n                // store the probability\n                // From the YIN paper: The threshold determines the list of\n                // candidates admitted to the set, and can be interpreted as the\n                // proportion of aperiodic power tolerated\n                // within a periodic signal.\n                //\n                // Since we want the periodicity and and not aperiodicity:\n                // periodicity = 1 - aperiodicity\n                probability = 1 - yinBuffer[tau];\n                break;\n            }\n        }\n        // if no pitch found, return null.\n        if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n            return null;\n        }\n        // If probability too low, return -1.\n        if (probability < probabilityThreshold) {\n            return null;\n        }\n        /**\n         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n         * value using parabolic interpolation. This is needed to detect higher\n         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n         * for more background\n         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n         */\n        var betterTau, x0, x2;\n        if (tau < 1) {\n            x0 = tau;\n        }\n        else {\n            x0 = tau - 1;\n        }\n        if (tau + 1 < yinBufferLength) {\n            x2 = tau + 1;\n        }\n        else {\n            x2 = tau;\n        }\n        if (x0 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x2]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x2;\n            }\n        }\n        else if (x2 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x0]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x0;\n            }\n        }\n        else {\n            var s0 = yinBuffer[x0];\n            var s1 = yinBuffer[tau];\n            var s2 = yinBuffer[x2];\n            // fixed AUBIO implementation, thanks to Karl Helgason:\n            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n        }\n        return sampleRate / betterTau;\n    };\n}\nexports.YIN = YIN;\n\n};"],
"names":["shadow$provide","global","require","module","exports","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","defineProperty","value","DEFAULT_YIN_PARAMS","threshold","sampleRate","probabilityThreshold","YIN","params","config","YINDetector","float32AudioBuffer","bufferSize","yinBufferLength","yinBuffer","Float32Array","probability","delta","runningSum","tau","x0","x2","betterTau","s0","s2","s1"]
}
