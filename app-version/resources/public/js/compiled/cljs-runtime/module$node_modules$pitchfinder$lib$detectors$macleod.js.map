{
"version":3,
"file":"module$node_modules$pitchfinder$lib$detectors$macleod.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/pitchfinder/lib/detectors/macleod.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pitchfinder$lib$detectors$macleod\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_MACLEOD_PARAMS = {\n    bufferSize: 1024,\n    cutoff: 0.97,\n    sampleRate: 44100,\n};\nfunction Macleod(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_MACLEOD_PARAMS), params);\n    var bufferSize = config.bufferSize, cutoff = config.cutoff, sampleRate = config.sampleRate;\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    var SMALL_CUTOFF = 0.5;\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    var LOWER_PITCH_CUTOFF = 80;\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    var nsdf = new Float32Array(bufferSize);\n    /**\n     * Contains a sum of squares of the Buffer, for improving performance\n     * (avoids redoing math in the normalized square difference function)\n     */\n    var squaredBufferSum = new Float32Array(bufferSize);\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    var turningPointX;\n    var turningPointY;\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    var maxPositions = [];\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    var periodEstimates = [];\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    var ampEstimates = [];\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    function normalizedSquareDifference(float32AudioBuffer) {\n        var acf;\n        var divisorM;\n        squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n        for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n            squaredBufferSum[i] =\n                float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n        }\n        for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n            acf = 0;\n            divisorM =\n                squaredBufferSum[float32AudioBuffer.length - 1 - tau] +\n                    squaredBufferSum[float32AudioBuffer.length - 1] -\n                    squaredBufferSum[tau];\n            for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n                acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n            }\n            nsdf[tau] = (2 * acf) / divisorM;\n        }\n    }\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    function parabolicInterpolation(tau) {\n        var nsdfa = nsdf[tau - 1], nsdfb = nsdf[tau], nsdfc = nsdf[tau + 1], bValue = tau, bottom = nsdfc + nsdfa - 2 * nsdfb;\n        if (bottom === 0) {\n            turningPointX = bValue;\n            turningPointY = nsdfb;\n        }\n        else {\n            var delta = nsdfa - nsdfc;\n            turningPointX = bValue + delta / (2 * bottom);\n            turningPointY = nsdfb - (delta * delta) / (8 * bottom);\n        }\n    }\n    // Finds the highest value between each pair of positive zero crossings.\n    function peakPicking() {\n        var pos = 0;\n        var curMaxPos = 0;\n        // find the first negative zero crossing.\n        while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n            pos++;\n        }\n        // loop over all the values below zero.\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++;\n        }\n        // can happen if output[0] is NAN\n        if (pos == 0) {\n            pos = 1;\n        }\n        while (pos < nsdf.length - 1) {\n            if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n                if (curMaxPos == 0) {\n                    // the first max (between zero crossings)\n                    curMaxPos = pos;\n                }\n                else if (nsdf[pos] > nsdf[curMaxPos]) {\n                    // a higher max (between the zero crossings)\n                    curMaxPos = pos;\n                }\n            }\n            pos++;\n            // a negative zero crossing\n            if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                // if there was a maximum add it to the list of maxima\n                if (curMaxPos > 0) {\n                    maxPositions.push(curMaxPos);\n                    curMaxPos = 0; // clear the maximum position, so we start\n                    // looking for a new ones\n                }\n                while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                    pos++; // loop over all the values below zero\n                }\n            }\n        }\n        if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n        }\n    }\n    return function Macleod(float32AudioBuffer) {\n        // 0. Clear old results.\n        var pitch;\n        maxPositions = [];\n        periodEstimates = [];\n        ampEstimates = [];\n        // 1. Calculute the normalized square difference for each Tau value.\n        normalizedSquareDifference(float32AudioBuffer);\n        // 2. Peak picking time: time to pick some peaks.\n        peakPicking();\n        var highestAmplitude = -Infinity;\n        for (var i = 0; i < maxPositions.length; i++) {\n            var tau = maxPositions[i];\n            // make sure every annotation has a probability attached\n            highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n            if (nsdf[tau] > SMALL_CUTOFF) {\n                // calculates turningPointX and Y\n                parabolicInterpolation(tau);\n                // store the turning points\n                ampEstimates.push(turningPointY);\n                periodEstimates.push(turningPointX);\n                // remember the highest amplitude\n                highestAmplitude = Math.max(highestAmplitude, turningPointY);\n            }\n        }\n        if (periodEstimates.length) {\n            // use the overall maximum to calculate a cutoff.\n            // The cutoff value is based on the highest value and a relative\n            // threshold.\n            var actualCutoff = cutoff * highestAmplitude;\n            var periodIndex = 0;\n            for (var i = 0; i < ampEstimates.length; i++) {\n                if (ampEstimates[i] >= actualCutoff) {\n                    periodIndex = i;\n                    break;\n                }\n            }\n            var period = periodEstimates[periodIndex], pitchEstimate = sampleRate / period;\n            if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n                pitch = pitchEstimate;\n            }\n            else {\n                pitch = -1;\n            }\n        }\n        else {\n            // no pitch detected.\n            pitch = -1;\n        }\n        return {\n            probability: highestAmplitude,\n            freq: pitch,\n        };\n    };\n}\nexports.Macleod = Macleod;\n\n};"],
"names":["shadow$provide","global","require","module","exports","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","defineProperty","value","DEFAULT_MACLEOD_PARAMS","bufferSize","cutoff","sampleRate","Macleod","params","config","nsdf","Float32Array","squaredBufferSum","turningPointX","turningPointY","maxPositions","periodEstimates","ampEstimates","float32AudioBuffer","tau","acf","divisorM","curMaxPos","pos","push","highestAmplitude","Infinity","Math","max","SMALL_CUTOFF","nsdfa","nsdfb","nsdfc","bottom","bValue","delta","actualCutoff","periodIndex","pitchEstimate","period","pitch","LOWER_PITCH_CUTOFF","probability","freq"]
}
