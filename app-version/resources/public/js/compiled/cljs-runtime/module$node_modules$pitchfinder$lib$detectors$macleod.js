shadow$provide.module$node_modules$pitchfinder$lib$detectors$macleod=function(global,require,module,exports){var __assign=this&&this.__assign||function(){__assign=Object.assign||function(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&(t[p]=s[p])}return t};return __assign.apply(this,arguments)};Object.defineProperty(exports,"__esModule",{value:!0});var DEFAULT_MACLEOD_PARAMS={bufferSize:1024,cutoff:.97,sampleRate:44100};exports.Macleod=
function(params){void 0===params&&(params={});params=__assign(__assign({},DEFAULT_MACLEOD_PARAMS),params);var bufferSize=params.bufferSize,cutoff=params.cutoff,sampleRate=params.sampleRate,nsdf=new Float32Array(bufferSize),squaredBufferSum=new Float32Array(bufferSize),turningPointX,turningPointY,maxPositions=[],periodEstimates=[],ampEstimates=[];return function(float32AudioBuffer){maxPositions=[];periodEstimates=[];ampEstimates=[];squaredBufferSum[0]=float32AudioBuffer[0]*float32AudioBuffer[0];for(var i=
1;i<float32AudioBuffer.length;i+=1)squaredBufferSum[i]=float32AudioBuffer[i]*float32AudioBuffer[i]+squaredBufferSum[i-1];for(var tau=0;tau<float32AudioBuffer.length;tau++){var pitch=0;var divisorM=squaredBufferSum[float32AudioBuffer.length-1-tau]+squaredBufferSum[float32AudioBuffer.length-1]-squaredBufferSum[tau];for(i=0;i<float32AudioBuffer.length-tau;i++)pitch+=float32AudioBuffer[i]*float32AudioBuffer[i+tau];nsdf[tau]=2*pitch/divisorM}for(pitch=float32AudioBuffer=0;float32AudioBuffer<(nsdf.length-
1)/3&&0<nsdf[float32AudioBuffer];)float32AudioBuffer++;for(;float32AudioBuffer<nsdf.length-1&&0>=nsdf[float32AudioBuffer];)float32AudioBuffer++;for(0==float32AudioBuffer&&(float32AudioBuffer=1);float32AudioBuffer<nsdf.length-1;)if(nsdf[float32AudioBuffer]>nsdf[float32AudioBuffer-1]&&nsdf[float32AudioBuffer]>=nsdf[float32AudioBuffer+1]&&(0==pitch?pitch=float32AudioBuffer:nsdf[float32AudioBuffer]>nsdf[pitch]&&(pitch=float32AudioBuffer)),float32AudioBuffer++,float32AudioBuffer<nsdf.length-1&&0>=nsdf[float32AudioBuffer])for(0<
pitch&&(maxPositions.push(pitch),pitch=0);float32AudioBuffer<nsdf.length-1&&0>=nsdf[float32AudioBuffer];)float32AudioBuffer++;0<pitch&&maxPositions.push(pitch);float32AudioBuffer=-Infinity;for(pitch=0;pitch<maxPositions.length;pitch++){var tau$jscomp$0=maxPositions[pitch];float32AudioBuffer=Math.max(float32AudioBuffer,nsdf[tau$jscomp$0]);if(.5<nsdf[tau$jscomp$0]){i=nsdf[tau$jscomp$0-1];divisorM=nsdf[tau$jscomp$0];tau=nsdf[tau$jscomp$0+1];var bottom=tau+i-2*divisorM;0===bottom?(turningPointX=tau$jscomp$0,
turningPointY=divisorM):(i-=tau,turningPointX=tau$jscomp$0+i/(2*bottom),turningPointY=divisorM-i*i/(8*bottom));ampEstimates.push(turningPointY);periodEstimates.push(turningPointX);float32AudioBuffer=Math.max(float32AudioBuffer,turningPointY)}}if(periodEstimates.length){divisorM=cutoff*float32AudioBuffer;for(pitch=i=0;pitch<ampEstimates.length;pitch++)if(ampEstimates[pitch]>=divisorM){i=pitch;break}pitch=sampleRate/periodEstimates[i];pitch=80<pitch?pitch:-1}else pitch=-1;return{probability:float32AudioBuffer,
freq:pitch}}}}
//# sourceMappingURL=module$node_modules$pitchfinder$lib$detectors$macleod.js.map
